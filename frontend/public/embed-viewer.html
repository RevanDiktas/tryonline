<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TryOn Embedded Viewer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: transparent; }
    #canvas-container { width: 100%; height: 100%; }
    .loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-family: system-ui; font-size: 14px; color: #666; }
    .loading.hidden { display: none; }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <div id="loading" class="loading">Loading...</div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // DOM
    const container = document.getElementById('canvas-container');
    const loading = document.getElementById('loading');

    // GLB paths - same as test-viewer
    const modelPaths = {
      xs: 'models/avatar_with_tshirt_xs.glb',
      s: 'models/avatar_with_tshirt_s.glb',
      m: 'models/avatar_with_tshirt_m.glb',
      l: 'models/avatar_with_tshirt_l.glb',
      xl: 'models/avatar_with_tshirt_xl.glb',
    };

    // Get size from URL hash
    const getSize = () => {
      const hash = window.location.hash.slice(1);
      return ['xs', 's', 'm', 'l', 'xl'].includes(hash) ? hash : 'm';
    };

    // State
    const modelCache = {};
    let currentSize = getSize();
    let currentModel = null;
    let scene, camera, renderer, controls;
    const gltfLoader = new GLTFLoader();

    // ============================================
    // PRELOAD ALL MODELS
    // ============================================
    function preloadAllModels() {
      Object.entries(modelPaths).forEach(([size, path]) => {
        gltfLoader.load(path, (gltf) => {
          modelCache[size] = gltf.scene.clone();
          modelCache[size].traverse((child) => {
            if (child.isMesh) {
              child.castShadow = false;
              child.receiveShadow = false;
              if (child.material) {
                child.material = child.material.clone();
                child.material.needsUpdate = true;
              }
            }
          });
          // Show initial model when it's ready
          if (size === currentSize && !currentModel) {
            displayModel(size);
            loading.classList.add('hidden');
          }
        });
      });
    }

    // ============================================
    // INIT SCENE - exact copy from test-viewer
    // ============================================
    function initScene() {
      scene = new THREE.Scene();

      const aspect = container.clientWidth / container.clientHeight;
      camera = new THREE.PerspectiveCamera(28, aspect, 0.1, 100);
      camera.position.set(0, 1.0, 4.5);

      renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        alpha: true,
        premultipliedAlpha: false
      });
      renderer.setClearColor(0x000000, 0);
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.8;
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      container.appendChild(renderer.domElement);

      // Controls - exact copy
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enablePan = true;
      controls.enableZoom = true;
      controls.enableRotate = true;
      controls.panSpeed = 1.5;
      controls.rotateSpeed = 1.2;
      controls.zoomSpeed = 2.0;
      controls.minDistance = 1.5;
      controls.maxDistance = 10;
      controls.minPolarAngle = 0;
      controls.maxPolarAngle = Math.PI;
      controls.target.set(0, 0.9, 0);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.update();

      // Lighting - exact copy
      scene.add(new THREE.AmbientLight(0xffffff, 2.0));

      const frontLight = new THREE.DirectionalLight(0xffffff, 1.5);
      frontLight.position.set(0, 2, 5);
      scene.add(frontLight);

      const backLight = new THREE.DirectionalLight(0xffffff, 1.5);
      backLight.position.set(0, 2, -5);
      scene.add(backLight);

      const leftLight = new THREE.DirectionalLight(0xffffff, 1.2);
      leftLight.position.set(-5, 2, 0);
      scene.add(leftLight);

      const rightLight = new THREE.DirectionalLight(0xffffff, 1.2);
      rightLight.position.set(5, 2, 0);
      scene.add(rightLight);

      const topLight = new THREE.DirectionalLight(0xffffff, 1.0);
      topLight.position.set(0, 6, 0);
      scene.add(topLight);

      const bottomLight = new THREE.DirectionalLight(0xffffff, 0.6);
      bottomLight.position.set(0, -3, 0);
      scene.add(bottomLight);

      scene.add(new THREE.HemisphereLight(0xffffff, 0xffffff, 0.8));
    }

    // ============================================
    // SHOW MODEL - exact copy from test-viewer
    // ============================================
    function showModel(size) {
      if (!modelCache[size]) {
        loading.classList.remove('hidden');
        gltfLoader.load(modelPaths[size], (gltf) => {
          modelCache[size] = gltf.scene.clone();
          displayModel(size);
          loading.classList.add('hidden');
        });
        return;
      }
      displayModel(size);
    }

    // ============================================
    // DISPLAY MODEL - exact copy from test-viewer
    // ============================================
    function displayModel(size) {
      if (currentModel) {
        scene.remove(currentModel);
      }

      currentModel = modelCache[size].clone();

      // Center model - exact copy
      const box = new THREE.Box3().setFromObject(currentModel);
      const center = box.getCenter(new THREE.Vector3());
      const modelSize = box.getSize(new THREE.Vector3());
      
      currentModel.position.x = -center.x;
      currentModel.position.y = -center.y + modelSize.y / 2;
      currentModel.position.z = -center.z;

      scene.add(currentModel);
      
      controls.target.set(0, modelSize.y / 2, 0);
      controls.update();
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    function onResize() {
      if (!renderer) return;
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    }

    // Listen for size changes via hash
    window.addEventListener('hashchange', () => {
      currentSize = getSize();
      showModel(currentSize);
    });

    window.addEventListener('resize', onResize);

    // START
    initScene();
    preloadAllModels();
    animate();
  </script>
</body>
</html>
